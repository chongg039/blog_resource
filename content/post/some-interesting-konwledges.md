---
title: "一些有意思的知识点整理"
date: 2020-03-12T16:02:41+08:00
Description: ""
Tags: []
Categories: []

---

### 一致性哈希算法

背景：有n个服务器做缓存，负载均衡的做法。

答：hash，对用户的序列（如IP）取n模，分发到对应的服务器上；

问：此时有一台宕机，或是业务需要新增了服务器，此时大多数用户的请求都会转到其他服务器，这样会发生大量访问错误，有没有办法。

思考：还是用hash，但需要像一个保证在增加和删除哈希模值时不会发生变化的情况，或发生了变化但可以纠正。

答：比如宕机一台，剩余n-1，首先还是模n，若分发的服务器不是宕机的服务器则不需要变动；若是，再对n-1取模，分发到任意一台完好的服务器中。若宕机m台，依照该思路每次减一求模直到n-m。
（但是对增加新的服务器，这种方式不是很好）

有没有更好的办法：一致性哈希，基本思路就是将服务器和用户请求散列到一个相同的区间上，使用相同的hash算法，因为hash的特殊作用可以把它想象成一个首尾相接的环。将散列后的用户顺时针查找第一个遇到的服务器作为对应的服务器，这样当环上增加或减少某个服务器节点，影响的将是有限个用户，并可以找到新的对应分配的服务器。

保证一致性哈希算法的平衡性，需要使用虚拟节点技术。

建议阅读[博客](https://blog.csdn.net/v_july_v/article/details/6879101)。

### BitMap算法

减少数据存放的占用内存大小的方式。考虑一个4字节int数值，也就是32bit，当有10000000个int会占用

4*10000000/1024/1024=38MB

若一个字节，占8bit，每个bit位用来标识下标数字是否存在，共需要

10000000/8/1024/1024=1.2MB

BitMap适合处理大量数据的加载、排序（鸽巢）和查询，缺点是无法对存在重复的数据进行排序和查找。做到这个需要建立一个十进制到二进制bit位的映射。

假设需要排序或者查找的总数N=10000000，那么我们需要申请的内存空间为 int a[N/32 + 1]。其中a[0]在内存中占32位：

```
a[0] ------> 0 - 31

a[1] ------> 32 - 63

a[2] ------> 64 - 95

a[3] ------> 96 - 127

...
```

需要以下转换：

1. 求十进制数 0-N 对应的在数组 a 中的下标。index_loc = N / 32即可，index_loc即为n对应的数组下标。例如n = 76，则loc = 76 / 32 = 2，因此76在a[2]中；
2. 求十进制数 0-N 对应的bit位。bit_loc = N % 32即可，例如 n = 76，bit_loc = 76 % 32 = 12；
3. 利用移位 0-31 使得对应的 32bit 位为 1 。

建议阅读[博客](https://www.cnblogs.com/chanshuyi/p/5287825.html)。

一般见到不重复的大量数字，都可以用位图。

### 布隆过滤器

用于反向检测新来的字段是否已经在现有的集合中，若多个哈希值中有一个在过滤器数组中的值为0，则一定不存在；若都为一，只能说可能存在，有一定的误判率。

为了防止过滤器内部都为1的情况，一般长度要远大于集合中的个数，因此就非常适合上面的BitMap的思想，采用一个bit数组作为布隆过滤器的实际载体。

布隆过滤器支持isexist和add操作，不支持delete，解决这个方法可以使用引用计数，但就不能采用bit操作的形式了，应该存储数值。

刚才说到布隆过滤器越长，误报率越低。哈希函数的个数也和这个有关，个数越多，过滤器置1的速度越快，效率也会变低。但是个数太少，误报率也会变高。因此对于哈希函数的个数k和布隆过滤器长度的选择m，有以下公式，其中n为插入元素个数，p为误报率：

$$m = -\frac{nlnp}{(ln2)^2}$$

$$k = \frac{m}{n}ln2$$

建议阅读[博客](https://juejin.im/post/5de1e37c5188256e8e43adfc)

利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。其他常用情景有：
1. 网页爬虫对URL的去重，避免爬取相同的URL地址；
2. 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）；
3. 缓存穿透，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。

Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。

拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。

### 缓存穿透、缓存击穿、缓存雪崩

[博客](https://blog.csdn.net/zeb_perfect/article/details/54135506)

### Trie树

Trie树也叫字典树、前缀树，是一种多叉树，如图

![GZdDqC](https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/GZdDqC.jpg)

1. 根节点不包含字符，是空字符；
2. 根节点到某一个节点，路径连接起来为该节点的字符串；
3. 每个节点所有的子节点互不相同；
4. 每个节点会有一个标志位标识该处是否构成一个单词。

显然插入和查询效率很高，都是O(m)，m为要查询或插入的字符串长度，并且是按照字典排序的。但是会占用比较多的空间，如果按照小写英文字符存放，就是一颗26叉树，可以这样定义：

```c++
struct trie_node
{
    bool isKey;   // 标记该节点是否代表一个关键字
    trie_node *children[26]; // 各个子节点 
};
```

Trie树应用：

1. 字符串检索，非常适合数据量很大，但大部分都是重复的情况；
2. 词频统计，可以修改节点结构，添加一个int变量记录该节点代表的单词个数，代替isKey；
3. 对大量字符串按照字典排序：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后**先序遍历**输出Trie树中所有关键字即可；
4. 前缀匹配，如需要查找以ab开头的所有字符串，构造一个Trie树，并遍历该路径上面的关键字即可。

### map-reduce

分布式计算，基本上就是map-reduce过程，首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。

适用于数据量大，但按照种类划分后每个种类都可以装入内存。